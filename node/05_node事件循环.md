# node事件循环

---

### 一、node的架构分析

1. 浏览器中的EventLoop是根据HTML5定义的规范来实现的，不同的浏览器可能会有不同的实现，而Node中是由libuv实现的
2. node架构图：
   1. ![](https://tva1.sinaimg.cn/large/e6c9d24ely1h4z7hcvumbj21620ekmz0.jpg)
   2. libuv中主要维护了一个EventLoop和worker threads（线程池）
   3. EventLoop负责调用系统的一些其他操作：文件的IO、Network、child-processes等
   4. libuv是一个多平台的专注于异步IO的库，它最初是为Node开发的，但是现在也被使用到Luvit、Julia、pyuv等其
      他地方


---

### 二、阻塞IO和非阻塞IO

1. 如果在程序中对一个文件进行操作，那么就需要打开这个文件：通过文件描述符。

2. JavaScript看起来可以直接对一个文件进行操作，事实上我们任何程序中的文件操作都是需要进行系统调用（操作系统的文件系统）

3. 事实上对文件的操作，是一个操作系统的IO操作（输入、输出）

4. 操作系统提供了`阻塞式调用`和`非阻塞式调用`：

   1. 阻塞式调用： 调用结果返回之前，当前线程处于阻塞态（阻塞态CPU是不会分配时间片的），调用线程只有
      在得到调用结果之后才会继续执行。
   2. 非阻塞式调用： 调用执行之后，当前线程不会停止执行，只需要过一段时间来检查一下有没有结果返回即可。

5. 开发中的很多耗时操作，都可以基于`非阻塞式调用`：

   1. 比如网络请求本身使用了Socket通信，而Socket本身提供了select模型，可以进行非阻塞方式的工作；
   2. 比如文件读写的IO操作，可以使用操作系统提供的基于事件的回调机制；

6. 非阻塞IO的问题：

   1. 我们并没有获取到需要读取（我们以读取为例）的结果

   2. 就意味着为了可以知道是否读取到了完整的数据，我们需要频繁的去确定读取到的数据是否是完整的；

   3. 这个过程称之为`轮询`操作；（那么这个轮训的工作由谁来完成呢？）

      1. 如果主线程频繁的去进行轮询的工作，必然会大大降低性能；
      2. 并且开发中可能不只是一个文件的读写，可能是多个文件；
      3. 而且可能是多个功能：网络的IO、数据库的IO、子进程调用；

   4. libuv提供了一个线程池（Thread Pool）：

      1. 线程池会负责所有相关的操作，并且会通过轮询等方式等待结果；
      2. 当获取到结果时，就可以将对应的回调放到事件循环（某一个事件队列）中；
      3. 事件循环就可以负责接管后续的回调工作，告知JavaScript应用程序执行对应的回调函数；

   5. ![](https://tva1.sinaimg.cn/large/e6c9d24ely1h4z7srfx8wj20lk0amt9j.jpg)

   6. 阻塞和非阻塞，同步和异步的区别？

      1. 阻塞和非阻塞是对于被调用者来说的；

         1. 这里就是系统调用，操作系统提供了阻塞调用和非阻塞调用；

      2. 同步和异步是对于调用者来说的；

         1. 这里就是自己的程序；
         2. 如果发起调用之后，不会进行其他任何的操作，只是等待结果，这个过程就称之为同步调用；
         3. 如果发起调用之后，并不会等待结果，继续完成其他的工作，等到有回调时再去执行，这个过程就是异步调用；

      3. 经典故事案例：

         1. 人物：老张

         2. 道具：普通水壶（水烧开不响）；响水壶（水烧开发出响声）

         3. 案例：

            ```c
            1、同步阻塞：
            老张在厨房用普通水壶烧水，一直在厨房等着（阻塞），盯到水烧开（同步）；
              
            2、异步阻塞：
            老张在厨房用响水壶烧水，一直在厨房中等着（阻塞），直到水壶发出响声（异步），老张知道水烧开了；
              
            3、同步非阻塞：
            老张在厨房用普通水壶烧水，在烧水过程中，就到客厅去看电视（非阻塞），然后时不时去厨房看看水烧开了没（轮询检查同步结果）；
              
            4、异步非阻塞：
            老张在厨房用响水壶烧水，在烧水过程中，就到客厅去看电视（非阻塞），当水壶发出响声（异步），老张就知道水烧开了。
            ```

      4. Libuv采用的就是非阻塞异步IO的调用方式；


---

### 三、node事件循环的阶段

1. 事件循环像是一个桥梁，是连接着应用程序的JavaScript和系统调用之间的通道：

   1. 无论是文件IO、数据库、网络IO、定时器、子进程，在完成对应的操作后，都会将对应的结果和回调函数放到事件循环（任务队列）中；
   2. 事件循环会不断的从任务队列中取出对应的事件（回调函数）来执行；

2. 一次完整的事件循环Tick分成很多个阶段：

   1. 定时器（Timers）：本阶段执行已经被 setTimeout() 和 setInterval() 的调度回调函数
   2. 待定回调（Pending Callback）：对某些系统操作（如TCP错误类型）执行回调，比如TCP连接时接收到ECONNREFUSED
   3. idle, prepare：仅系统内部使用
   4. 轮询（Poll）：检索新的 I/O 事件；执行与 I/O 相关的回调
   5. 检测：setImmediate() 回调函数在这里执行
   6. 关闭的回调函数：一些关闭的回调函数，如：socket.on('close', ...)

3. node事件循环阶段图解：

   ![](https://tva1.sinaimg.cn/large/e6c9d24ely1h4z94yyxhgj21g10u0ac5.jpg)

---

### 四、node的微任务和宏任务

1. 从一次事件循环的Tick来说，Node的事件循环更复杂，它也分为微任务和宏任务：
   1. 宏任务（macrotask）：setTimeout、setInterval、IO事件、setImmediate、close事件；
   2. 微任务（microtask）：Promise的then回调、process.nextTick、queueMicrotask；
2. Node中的事件循环不只是 微任务队列和 宏任务队列：
   1. 微任务队列：
      1. next tick queue：process.nextTick；
      2. other queue：Promise的then回调、queueMicrotask；
   2. 宏任务队列：
      1. timer queue：setTimeout、setInterval；
      2. poll queue：IO事件；
      3. check queue：setImmediate；
      4. close queue：close事件；

---

### 五、面试题分析：

1. setTimeout(回调函数, 0)、setImmediate(回调函数)执行顺序分析
   1. 情况一： setTimeout、setImmediate
   2. 情况二：setImmediate、setTimeout
2. 为什么会出现不同的情况呢？
   1. 情况一：如果事件循环开启的时间(ms)是小于 setTimeout函数的执行时间的；
      1. 就意味着先开启了event-loop，但是这个时候执行到timer阶段，并没有定时器的回调被放到入 timer queue中
      2. 所以没有被执行，后续开启定时器和检测到有setImmediate时，就会跳过poll阶段，向后继续执行
      3. 这个时候是先检测 setImmediate，第二次的tick中执行了timer中的setTimeout
   2. 情况二：如果事件循环开启的时间(ms)是大于 setTimeout函数的执行时间的；
      1. 意味着在第一次 tick中，已经准备好了timer queue；
      2. 所以会直接按照顺序执行即可；

